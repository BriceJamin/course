# -*- coding: utf-8 -*-
# -*- fill-column: 54 -*-
## FORMAT DU FICHIER
## Tout ce qui commence avec un ## est un commentaire
##
## le texte entre double crochets ouvrants et fermants
## est à synchroniser avec les slides. [SB] signifie slide blanc,
## c'est à dire qu'il n'y pas de transparent affiché à ce moment (ou
## un transparent blanc). [Si] signifie que l'on doit se trouver sur
## le slide i

## TITRE : Portée des variables dans les fonctions : règle LEGB
## Temp total: 9m35s

## Résumé de la vidéo (3m15s)

>>>>>>>>>> W4-S4-AV-slide1.pptx <<<<<<<<<< 

[s1]

Nous avons déjà parlé de la notion de blocs de code. Un [bloc de code]
est un ensemble de lignes de code contigues qui ont la même
indendation et qui sont précédée par un ":", sauf pour le bloc de code
du module qui est lui sans aucune indentation. Après chaque if, chaque
for ou chaque fonction j'ai un bloc de code.

[s2]

[Une variable définie dans un bloc de code] peut être accédée par
toutes les lignes dans le même bloc de code. Ce que l'on appelle la
portée d'une variable définie [dans quels *autres* blocs de code]
cette variable peut-être accédée.

[s3]

Nous allons voir dans cette vidéo la notion de portée des
variables. Python utilise ce que l'on appelle la portée lexicale,
c'est-à-dire que la portée d'une variable est déterminée en fonction
du bloc de code dans lequel elle est définie.  On dit qu'une variable
est définie lorsqu'elle référence un objet. On peut par exemple faire
[x = 1] pour définir la variable x en lui faisant référencer l'objet
entier 1.

Les termes [définition, affectation, assignation et binding] sont tous
équivalents.

Il existe deux types de portée de variables. La portée locale et la
portée globale. Notons que par extension de langage, on utilise
fréquement le terme variable locale ou globale au lieu de variable de
porté locale ou globale.

Une variable définie dans le bloc de code d'une fonction sera une
variable locale au bloc de code de cette fonction. Elle ne pourra pas
être accédée en dehors de ce bloc de code. Elle sera créée à l'appel
de la fonction et détruite lorsque la fonction retourne. Notons qu'une
variable définie dans l'entête de la fonction est également une
variable locale à cette fonction. 

Une variable définie en dehors de toute fonction sera une variable
globale, elle sera accessible n'importe où dans le module où est
définie cette variable.
[[TP en me relisant je me rends compte qu'une précaution oratoire
vis-à-vis des classes pourrait être nécessaire]]

En résumé, une variable est locale lorsqu'elle est définie dans une
fonction, sinon elle est globale.

Il y a ici une subtilité importante. Une variable globale est visible
dans tout le module dans lequel elle est défini. Il n'y a rien de plus
visible ou accessible qu'une variable globale. Mais notez bien 
qu'une variable définie dans un module ne peut pas être directement
vue dans un autre module. De cette façon, deux variables de même nom
dans deux modules différents peuvent coexiter tout en étant totalement indépendantes. Ce
mécanisme d'isolation que l'on appelle espace de nommage est une des
grandes forces de Python et nous reviendrons largement dessus dans de
prochaines vidéo en expliquant notamment comment accéder aux variables
définies dans un autre espace de nommage.

En résumé, il y a donc deux mécanismes très différents qui entre en jeux
lorsqu'on veut accéder à une variable. Si on veut accéder à une
variable qui est définie dans le même module (qu'elle soit locale ou
globale), c'est le mécanisme de portée des variables qui entre en
jeux. Si on veut accéder à une variable définie dans un autre module,
c'est le mécanisme des espaces de nommage qui entre en jeux. 

[s4]

Dans cette vidéo nous nous concentrerons sur la notion de portée de
variable. Python utilise une règle que l'on appelle [LEGB] lorsque
l'on référence une variable, c'est-à-dire lorsque l'on utilise son nom
en dehors d'une affectation. Lorsque l'on référence une variable, si
c'est une variable locale à une fonction, on la cherche d'abord
[localement] dans bloc de code de cette fonction, puis on la cherche
dans les [fonction englobante] s'il y en a de l'intérieur vers
l'extérieur, ensuite on la cherche [globalement] au niveau des
variables globales du module. Si elle n'est toujours pas trouvée on la
cherche en dernier ressort dans le module [builtins].

Ouvrons un éditeur IDLE pour commencer à jouer avec la notion de
portée des variables.


>>>>>>>>>> W4-S4-AV-exo1.py <<<<<<<<<< (5 minutes 40)


## conclusion (40s)

On vient de voir la notion de portée des variables et la règle
LEGB. Lorsque vous affectez une variable elle devient locale à son
bloc de code. Si le bloc de code est celui d'une fonction, la variable
sera locale, si le bloc de code est en dehors de toute fonction, la
variable sera globale dans le module. Lorsque l'on référence une
variable, on la cherche d'abord localement, puis dans les fonctions
englobante, puis globalement, et pour finir dans le module builtins. 
Prenez le temps de bien assimiler ces notions. Nous les compléterons
dans une prochaine vidéo lorsque nous parlerons des classes.

À bientôt. 
