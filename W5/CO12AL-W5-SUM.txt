
# TITRE SEMAINE 5 : Modules, classes et espaces de nommage

###################################################################

## Vidéo 1 (Modules et espaces de nommage)

CO12AL-W5-VIDEO01.txt

## Compléments Vidéo 1

*introduire __dict__, globals(), locals() et dir(mod) dans le contexte
des modules uniquement. (on parlera de __dict__ pour les classes
et les instance plus tard, mais tu peux déjà y faire allusion)

*introduire sys.modules

*parler de l'impossibilité de faire __dict__ du module courant
(en particulier du prompt interactif) et expliquer que l'on 
ne peut y accéder que depuis sys.modules[__name__].__dict__
Citer 
http://docs.python.org/2.6/tutorial/classes.html#id2
et
http://stackoverflow.com/questions/4877290/what-is-the-dict-dict-attribute-of-a-python-class

## Quizz Vidéo 1

## Exercices Vidéo 1


###################################################################

## Vidéo 2 (Processus d'importation des modules)

CO12AL-W5-VIDEO02.txt

## Compléments Vidéo 2

*exécuter un module comme un script avec 
if __name__ == '__main__':

*parler de sys.builtin_module_names et de, par exemple, math 
et sys, qui sont des modules built-in implémentés en C pour
des questions de vitesse. 

*compléter la discussion de la video sur les .pyc. Par exemple,
on peut directement distribuer les .pyc sans les .py

*parler de reload() et du problème classique de modifier un module,
l'importer de nouveau et ne pas voir les modifications. 

* directory courant 
import os
os.getcwd()
cette astuce pourra vous etre utile surtout si vous lancez idle a
partir d'un menu, comme c'est presque toujours le cas, et dans ces
cas-la il n'est pas toujours facile de savoir quel est exactement le repertoire courant, selon les systemes et les environnements

## Quizz Vidéo 2

## Exercices Vidéo 2

###################################################################

## Vidéo 3 (Importation de modules et espace de nommage)

CO12AL-W5-VIDEO03.txt

## Compléments Vidéo 3

*introduire 
import modulename as name
et
from modulename import attrname as name

* introduire __import__

*introduire 
from mod import *
en expliquant qu'il ne faut jamais le faire avec des modules
que l'on n'a pas écrit nous même parce qu'il y a un fort risque
de collision des espaces de nommage
Citer https://docs.python.org/2.7/reference/simple_stmts.html#the-import-statement
Introduire aussi les variables commençant par _ en expliquant que 
l'on ne doit pas les modifier et qu'elles ne sont pas importée par 
un import *

## Quizz Vidéo 3

## Exercices Vidéo 3

###################################################################

## Vidéo 4 (Classes, instances et méthodes)

CO12AL-W5-VIDEO04.txt

## Compléments Vidéo 4

* introduire getattr() et setattr()
* introduire la notion de variables privées _var
(privée et pas d'import par from mod import *), __var__ 

## Quizz Vidéo 4

## Exercices Vidéo 4

###################################################################

## Vidéo 5 (Héritage)

CO12AL-W5-VIDEO05.txt

## Compléments Vidéo 5

*introduire la MRO (Method Resolution Order)
http://python-history.blogspot.fr/2010/06/method-resolution-order.html
(attention cet article parle aussi des nouvelles classes)

*expliquer que seules les classes built-in ne sont pas mutables
parce que sinon ça pourrait rendre l'interpréteur instable. 

*citer (et peut-être discuter en montrer des exemples) 
design patterns et le livre de Gramma et al.

* introduire les variables __var (name mangling)
http://docs.python.org/2/reference/lexical_analysis.html#reserved-classes-of-identifiers

## Quizz Vidéo 5

## Exercices Vidéo 5

###################################################################

## Vidéo 6 (Surcharge d'opérateurs)

CO12AL-W5-VIDEO06.txt

## Compléments Vidéo 6

*Citer ce lien pour toutes les surcharges d'opérateurs. 
http://docs.python.org/2/reference/datamodel.html#special-method-names
*couvrir d'autres opérateurs (je couvre __init__ et __str__ en vidéo)
Il faut voir au minimum __call__, __add__, __contains__, __len__, __getattr__,
__nonzero__
* rappeler que le __iter__ est également une surcharge
* parler des fallback 
Itération : __iter__ puis __getitem__
in :  __contains__ puis __iter__ puis __getitem__
Test vrai/faux : __nonzero__ puis __len__ (faux si __len__ retourne 0)
print : __str__ puis __repr__

* parler de __call__ qui transforme une instance en un callable

*parler des optimisations de CPython sur les opérateurs
Plus rapide d'utiliser un opérateur que l'appel direct sur le méthode
>>> timeit.timeit(setup = "L = range(1000)", number = 100000000, stmt = "0 in L")
3.1706046182752914
>>> timeit.timeit(setup = "L = range(1000)", number = 100000000, stmt = "L.__contains__(0)")
11.681099249275206

## Quizz Vidéo 6

## Exercices Vidéo 6


###################################################################

## Vidéo 7 (Quand utiliser fonctions, modules ou classes ?)

CO12AL-W5-VIDEO07.txt

## Compléments Vidéo 7

## Quizz Vidéo 7

## Exercices Vidéo 7


###################################################################

## Vidéo 8 (Assignation et référencement des variables et des attributs)

CO12AL-W5-VIDEO08.txt

## Compléments Vidéo 8
citer: 
http://www.python.org/dev/peps/pep-0227/
http://docs.python.org/2.7/reference/executionmodel.html 
http://docs.python.org/2.7/tutorial/classes.html#python-scopes-and-namespaces 

*expliquer ce cas
class A:
    a = 42
    b = list(a + i for i in range(10))
>>>
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    class A:
  File "<pyshell#1>", line 3, in A
    b = list(a + i for i in range(10))
  File "<pyshell#1>", line 3, in <genexpr>
    b = list(a + i for i in range(10))
NameError: global name 'a' is not defined

*faire un notebook sur les règles pour ne pas tomber dans les
cas dangereux:
   -ne jamais utiliser comme nom de variable locale
   un nom qui existe en global
   -toujours mettre la directive global avec l'utilisation
   de la variable.
puis montrer quelques exemples d'erreurs quand on ne suit
pas ses règles
1) binding static au scope local pour les fonction uniquement
(optimisation de CPython) et la fameuse UnboundLocalError
var = 0
def func():
    print var
    var = 1
>>> func()

Traceback (most recent call last):
  File "<pyshell#102>", line 1, in <module>
    func()
  File "C:/Users/alegout/Desktop/test2.py", line 25, in func
    print var
UnboundLocalError: local variable 'var' referenced before assignment

x = "x dans module"
def f():
    if False:
        x = "x dans f()"
    print x
f()
>>> 
Traceback (most recent call last):
  File "C:/Users/alegout/Desktop/temp.py", line 6, in <module>
    f()
  File "C:/Users/alegout/Desktop/temp.py", line 5, in f
    print x
UnboundLocalError: local variable 'x' referenced before assignment

2) le bug http://bugs.python.org/issue532860

3) directive global apres l'utilisation de la variable

## Quizz Vidéo 8

## Exercices Vidéo 8

proposer quelques exercices un peu vicieux (avec des imports, des classes, des fonctions
englobantes, etc.)

