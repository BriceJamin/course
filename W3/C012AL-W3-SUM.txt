# -*- eval: (auto-fill-mode 0) -*-

# TITRE SEMAINE 3 : Références partagées et itérateurs 

###################################################################

## Vidéo 1 (Tables de hash)

C012AL-W3-S1.txt 

## Compléments Vidéo 1 
pas de complement ni exercice sur ce topic tres abstrait
## Quizz Vidéo 1
## Exercices Vidéo 1


###################################################################

## Vidéo 2 (Les dictionnaires)

C012AL-W3-S2.txt 

## Compléments Vidéo 2
OK dict-extras.ipynb - recapitulatif sur comment utiliser un dict + url vers la doc python
OK dict-key-immuable.ipynb - types immuables et clés globalement immuables
OK dict-as-struct.ipynb - une utilisation standard du dictionnaire pour faire un struct

## Quizz Vidéo 2
TODO: un quiz sur les dictionnaires

## Exercices Vidéo 2


###################################################################

## Vidéo 3 (Les ensembles)

C012AL-W3-S3.txt 

## Compléments Vidéo 3
OK set-extras.ipynb : recap. fonctions/methodes sur les ensembles

BOF *test de performance sur le test d'appartenance entre list et set
pour expliquer qu'il faut toujours utiliser des sets
>>> timeit.timeit(setup= "x = range(2)", stmt = '"c" in x', number = 6000000)
1.042163089558322
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '"c" in x', number = 6000000)
0.32964897792466274

>>> timeit.timeit(setup= "x = range(2)", stmt = '0 in x', number = 6000000)
0.3086782596151636
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '0 in x', number = 6000000)
0.3819173343944584


## Quizz Vidéo 3

## Exercices Vidéo 3

TODO : Mettre l'accent sur le choix judicieux du type de base en fonction du
probleme posé...

###################################################################

## Vidéo 4 (Les références partagées)

C012AL-W3-S4.txt 

## Compléments Vidéo 4
OK is-id.ipynb : function id(), operateur is,  les entiers implementes comme des singletons
OK references-circulaires.ipynb : une liste infinie; un exemple + utile de reference circulaire
OK copy.ipynb - make sure this comes after is-id 
OK del.ipynb *del a;  del L[i:j:k]; del d[clef]
OK assign-simultaneous.ipynb simultaneous assignement a = b = []

BOF gc.ipynb peut-etre plus tard mais je vois ca comme un truc super scabreux (si on veut le faire correctement)
en plus sys.getrefcount c'est un detail d'implementation; je sais pas si pypy a ça par exemple
* sys.getrefcount()

## Quizz Vidéo 4

## Exercices Vidéo 4

BOF * montrer le problème suivant L=[[1]]*5 et demander une solution pour ne pas avoir de ref. partagées
TODO * exo pour voir jusqu'à quelle taille de chaîne de caractères (et quelle taille d'entier) Python arrête de faire des références partagées pour optimiser la mémoire. 
TODO * essayer d'écrire un bout de code buggé et demander aux gens detrouver l'erreur en rajoutant une copie

###################################################################

## Vidéo 5 (Introduction aux modules)

C012AL-W3-S5.txt

## Compléments Vidéo 5
OK: packages.ipynb
ONGOING: modules-and-path.ipynb: 
  * où sont installées les librairies standard
  * comment ajouter un directory dans le chemin de recherche - parler de sys.path et PYTHONPATH
      (c'est un follow-up de shebang.py mais shebang était seulement pour linux et mac)
  * mentionner Python Standard Library https://docs.python.org/2/library/index.html

## Quizz Vidéo 5

## Exercices Vidéo 5

TODO decode-zen.ipynb : décoder le zen de python à partir de this (de import this)

###################################################################

## Vidéo 6 (L'indentation comme syntaxe de base)

C012AL-W3-S6.txt

## Compléments Vidéo 6
TODO parler des coupures de ligne - les parentheses et autres crochets
   # indentation - syntaxe minimale - presentation unifiee - 79 cars

-ajouter un lien vers la PEP 008 (sur les conventions de codage)
http://legacy.python.org/dev/peps/pep-0008/
-ajouter un lien vers cette FAQ https://docs.python.org/2/faq/design.html#why-are-colons-required-for-the-if-while-def-class-statements

## Quizz Vidéo 6

## Exercices Vidéo 6


###################################################################

## Vidéo 7 (Les tests if/elif/else et les opérateurs booléens)
# if avec resultat non booleen
# operateurs booleens - priorites..

C012AL-W3-S7.txt

## Compléments Vidéo 7

## Quizz Vidéo 7

## Exercices Vidéo 7

-opérateurs de tests booléens and, or, not (vu en cours, montrer
d'autres exemples)
-insister sur le fait qu'il vaut mieux mettre des paranthèses que 
de compter sur les priorités. 
-opération shortcircuit and et or. Montrer des exemples pour les 2.
-discuter de == : quand peut-on comparer des objets de types différents
(seulement les numériques, et les set et frozenset, str/unicode, mais
(1, 2) n'est pas égal à [1, 2])
-quel sens à des comparaisons (avec < ou >) de listes ou dicts. 
-parler de bool (qui permet de connaitre le résultat d'un test) 
(je rajoute __nonzero__ lorsque l'on parlera de surcharge, c'est trop
tôt maintenant)


###################################################################

## Vidéo 8 (Les boucles for et les itérateurs)

C012AL-W3-S8.txt
# for sur une sequence - for sur un objet qui a un iterateur -
# __iter__  / next / StopIteration

## Compléments Vidéo 8

- expliquer l'intérêt au niveau occupation mémoire des itérateurs
des types built-in.
-présenter break
-présenter continue (en expliquant que, comme pour les goto, les sauts
dans le code nuisent à la compréhension, il faut donc l'éviter)
-présenter pass qui est utilisé pour rendre syntaxiquement correct un bloc
de code que l'on n'a pas encore écrit (voir pour les fonctions, for, if)
-voir le else du for
-présenter enumerate, zip, et les itérateurs des dictionnaires
-présenter xrange() et sont avantage par rapport à range() (pas 
d'occupation mémoire). Dans le même esprit expliquer l'avantage
des itérateurs sur des dict (iteritems/itervalues/iterkeys) par rapport
aux listes. 
-présenter la méthode built-in iter() en expliquant que comme
__iter__() est une méthode Python privée, on ne doit pas l'appeler
directement dans un programme, on doit utiliser la built-in iter()
à la place.



Ici, sinon on a une boucle infinie.

## Quizz Vidéo 8

## Exercices Vidéo 8

Il ne faut pas modifier l'objet sur lequel on itère dans boucle for.
Si on modifie l'objet, il faut itérer sur copie
>>> L = ['a', 'b' , 'c']
>>> for i in L[:]:
	if i == 'c':
		L.append(i)	


