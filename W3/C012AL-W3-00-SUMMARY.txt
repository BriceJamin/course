# -*- eval: (auto-fill-mode 0) -*-

# TITRE SEMAINE 3 : Références partagées et itérateurs 

###################################################################

## Vidéo 1 (Tables de hash)

C012AL-W3-S1.txt 

## Compléments Vidéo 1 
pas de complement ni exercice sur ce topic tres abstrait
## Quizz Vidéo 1
## Exercices Vidéo 1


###################################################################

## Vidéo 2 (Les dictionnaires)

C012AL-W3-S2.txt 

## Compléments Vidéo 2
OK C012AL-W3-S2-C1-dict-extras.ipynb - recapitulatif sur comment utiliser un dict + url vers la doc python
OK C012AL-W3-S2-C2-dict-key-immuable.ipynb - types immuables et clés globalement immuables
OK C012AL-W3-S2-C3-dict-as-struct.ipynb - une utilisation standard du dictionnaire pour faire un struct

## Quizz Vidéo 2
OK C012AL-W3-S2-E1-dicts.quiz - un quiz sur les dictionnaires

## Exercices Vidéo 2
OK C012AL-W3-S2-E2-marine-dict.ipynb - premier morceau de code un peu réel avec data/marine*.json -- assez simple - data et corrections OK
				               	       	       	      
ONGOING C012AL-W3-S2-E2-meteo-pending-to-postpone.ipynb - premier morceau de code un peu réel avec data/meteo.json 

###################################################################

## Vidéo 3 (Les ensembles)

C012AL-W3-S3.txt 

## Compléments Vidéo 3
OK C012AL-W3-S3-C1-set-extras.ipynb : recap. fonctions/methodes sur les ensembles

-------- 
XXX Inutile en fait puisque j'en parle dans la dernière vidéo du MOOC
BOF *test de performance sur le test d'appartenance entre list et set
pour expliquer qu'il faut toujours utiliser des sets
>>> timeit.timeit(setup= "x = range(2)", stmt = '"c" in x', number = 6000000)
1.042163089558322
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '"c" in x', number = 6000000)
0.32964897792466274
>>> timeit.timeit(setup= "x = range(2)", stmt = '0 in x', number = 6000000)
0.3086782596151636
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '0 in x', number = 6000000)
0.3819173343944584
--------


## Quizz Vidéo 3

## Exercices Vidéo 3
NICETOHAVE : un quiz qui met l'accent sur le choix judicieux du type de base en fonction du probleme posé 
entre tuple, liste, dict, set (et pourquoi pas aussi frozenset si il faut hacher)

OK C012AL-W3-S3-E1-marine-set.ipynb - avec le même genre de données de marine traffic xxx version python à 
 
###################################################################

## Vidéo 4 (Les références partagées)

C012AL-W3-S4.txt 

## Compléments Vidéo 4
OK C012AL-W3-S4-C1-is-id.ipynb : function id(), operateur is,  les entiers implementes comme des singletons
OK C012AL-W3-S4-C2-references-circulaires.ipynb : une liste infinie; un exemple + utile de reference circulaire
OK C012AL-W3-S4-C3-copy.ipynb - make sure this comes after is-id 
OK C012AL-W3-S4-C4-del.ipynb *del a;  del L[i:j:k]; del d[clef]
OK C012AL-W3-S4-C5-assign-simultaneous.ipynb   a = b = []

BOF gc.ipynb peut-etre plus tard mais je vois ca comme un truc super scabreux (si on veut le faire correctement)
en plus sys.getrefcount c'est un detail d'implementation; je sais pas si pypy a ça par exemple
* sys.getrefcount()

## Quizz Vidéo 4
OK C012AL-W3-S4-E1-multiply.quiz liste=[[1]]*5 et demander une solution pour ne pas avoir de ref. partagées 

## Exercices Vidéo 4


DROPPED* exo pour voir jusqu'à quelle taille de chaîne de caractères (et quelle taille d'entier) 
                 Python arrête de faire des références partagées pour optimiser la mémoire. 
		 je laisse tomber car la fonction is_singleton e comporte de maniere bizarre
NICETOHAVE * essayer d'écrire un bout de code buggé et demander aux gens detrouver l'erreur en rajoutant une copie

###################################################################
## Vidéo 5 (Introduction aux modules)

C012AL-W3-S5.txt

## Compléments Vidéo 5
OK C012AL-W3-S5-C1-packages.ipynb
OK C012AL-W3-S5-C2-modules-and-path.ipynb: 
OK C012AL-W3-S5-C3-recap-import.ipynb : pourquoi il ne faut pas utiliser import *

## Exercices Vidéo 5
OK C012AL-W3-S5-E1-decode-zen.ipynb : décoder le zen de python à partir de this (de import this) 

## Quizz Vidéo 5  

NICETOHAVE un exo (sans correction) qui invite les etudiants
  (*) basique: creer un module dans leur workingdir et a l'importer
  (*) intermediaire: creer un package "utils" dans le workingdir avec un module dedans

ça pourrait se faire avec un quiz en dessous pour voir si les gens y arrivent,

###################################################################

## Vidéo 6 (L'indentation comme syntaxe de base)

C012AL-W3-S6.txt

## Compléments Vidéo 6
OK C012AL-W3-S6-C1-presentation.ipynb
OK C012AL-W3-S6-C2-pass.ipynb
-présenter pass qui est utilisé pour rendre syntaxiquement correct un bloc
de code que l'on n'a pas encore écrit (voir pour les fonctions, for, if)

## Quizz Vidéo 6

## Exercices Vidéo 6
XXX je n'ai aucune idée pour un exercice intéressant ici, ou bien alors peut être avec la formule
(notebook + quiz) qu'on a évoquée à un moment mais qu'on n'a pas encore pu essayer

###################################################################

## Vidéo 7 (Les tests if/elif/else et les opérateurs booléens)
# if avec resultat non booleen
# operateurs booleens - priorites..

C012AL-W3-S7.txt

## Compléments Vidéo 7
OK C012AL-W3-S7-C1-evaluation-tests.ipynb: évaluation paresseuse (repris et aménagé de W2-S6)
OK C012AL-W3-S7-C2-recap-cond.ipynb:  recap expressions dans un if

## Quizz Vidéo 7

## Exercices Vidéo 7

ONGOING: C012AL-W3-S7-E1-if.ipynb: des exercices sur des ifs un peu torturés 

###################################################################

## Vidéo 8 (Les boucles for et les itérateurs)

C012AL-W3-S8.txt
# for sur une sequence - for sur un objet qui a un iterateur -
# __iter__  / next / StopIteration

## Compléments Vidéo 8

OK C012AL-W3-S8-C1-break-continue.ipynb
TODO C012AL-W3-S8-C2-iterateur-memoire.ipynb: 
* basique 
- expliquer l'intérêt au niveau vitesse et occupation mémoire des itérateurs
- parler de xrange() vs range () / dict.{items, keys, values} 
mentionner python3
* avancé
illustrer avec un iterateur sur les permutations 

TODO C012AL-W3-S8-C3-keep-intact.ipynb: il ne faut pas pas modifier l'objet sur lequel on fait un for 
Il ne faut pas modifier l'objet sur lequel on itère dans boucle for.
Si on modifie l'objet, il faut itérer sur copie
>>> L = ['a', 'b' , 'c']
>>> for i in L[:]:
	if i == 'c':
		L.append(i)	


BOF : je laisse tomber tout ca
 -voir le else du for 
-présenter la méthode built-in iter() en expliquant que comme
__iter__() est une méthode Python privée, on ne doit pas l'appeler
directement dans un programme, on doit utiliser la built-in iter()
à la place.
Ici, sinon on a une boucle infinie.

## Quizz Vidéo 8

## Exercices Vidéo 8

TODO: C012AL-W3-S8-E1-for.ipynb: 
des exercices sur des fors un peu torturés  
 


