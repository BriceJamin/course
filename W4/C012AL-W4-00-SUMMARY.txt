# -*- eval: (auto-fill-mode 0) -*-

# TITRE SEMAINE 4 : Fonctions 

###################################################################

## Vidéo 1 (Les fichiers)
C012AL-W4-S1.txt
## Compléments Vidéo 1
OK C012AL-W4-S1-C1-file-extras.ipynb 
OKC012AL-W4-S1-C2-stdinouterr.ipynb : 
OK C012AL-W4-S1-C3-json.ipynb : parler de json, pickle, csv ...

DROPPED *montrer que sys.stdout n'est q'une variable qui peut référencer un autre fichier.
Comme print écrit dans sys.stdout, c'est un moyen simple de rediriger les print vers un fichier. (c'est très sale cette façon de faire..)

## Quizz Vidéo 1
## Exercices Vidéo 1
OK C012AL-W4-S1-E1-files.ipynb

###################################################################

## Vidéo 2 (Boucle while)
C012AL-W4-S2.txt
## Compléments Vidéo 2
OK C012AL-W4-S2-C1-while-extras.ipynb
## Quizz Vidéo 2
## Exercices Vidéo 2
OK C012AL-W4-S2-E1-pgcd.ipynb

###################################################################

## Vidéo 3 (Fonction lambda, programmation fonctionnelle)
C012AL-W4-S3.txt
## Compléments Vidéo 3
OK C012AL-W4-S3-C1-function-extras.ipynb

DROPPED *voir exec et eval. Ça n'est pas en lien direct, mais il faut
le voir et il y a peu de compléments pour cette vidéo alors
autant le placer ici. 

## Quizz Vidéo 3
NICETOHAVE C012AL-W4-S3-E1-functions.quiz
comparer def et lambda 
comparer map/filter 

## Exercices Vidéo 3
OK C012AL-W4-S3-E2-functions.ipynb

###################################################################

## Vidéo 4 (Compréhension de listes, sets et dictionnaires)

C012AL-W4-S4.txt

## Compléments Vidéo 4
OK C012AL-W4-S4-C1-multi-comp.ipynb compréhensions multiples 

DROPPED
*Comparer la performance des boucles for, de map, de la compréhension. - pas le temps
S'inspirer de : http://www-sop.inria.fr/members/Arnaud.Legout/EDU/Python/performanceFonctions2.py

## Quizz Vidéo 4

## Exercices Vidéo 4
un exo sur des manipulations simples d'ensembles,
un exo pour aplatir une liste de listes de niveau 1
###################################################################

## Vidéo 5 (Les fonctions)

C012AL-W4-S5.txt

## Compléments Vidéo 5

* cas pratique de plusieurs return 
* effet de bord du passage par ref de mutable (illustration de la video)
* expliquer comment ne pas modifier un mutable passé en argument:
reprendre l'exemple de la video

L = []
def h(a):
	a.append(1)

Comment ne pas modifier L. Trois possibilités:
-à l'appel h(L[:]) on passe une shallow copy, ça permet
de choisir la modification par effect de bord à l'appel
(peut-être utile lorsque la fonction fait autre chose avec L)
-à l'appel si on veut une exception en cas de tentative
de modification (utile pour les librairies) h(tuple(L))
-dans h en ajoutant a = a[:] avant le append pour garantir
que h ne modifiera jamais L. 
-parler de la documentation automatique sur les fonctions 
et de l'argument __doc__ utilisé par help()
def func(a, b, c, d):
    """
    Cette fonction imprime 4 parametres a la suite
    """
    print a, b, c, d
	
>>>print func.__doc__
 Cette fonction imprime 4 parametres a la suite
>>>help(func)
Help on function func in module __main__:

func(a, b, c, d)
    Cette fonction imprime 4 parametres a la suite

peut-etre l'occasion de reparler de isinstance en complement de la
    video qui parle de polymorphisme

## Quizz Vidéo 5

## Exercices Vidéo 5


###################################################################

## Vidéo 6 (Portée des variables dans les fonctions : règle LEG)

CO12AL-W4-VIDEO006.txt

## Compléments Vidéo 6

-parler du scope built-in et montrer le module built-in. 
-expliquer que les variables dans l'entête des fonctions sont
aussi des variables locales. 
-montrer que l'on peut redéfinir un nom built-in et que c'est
une mauvaise idée. 
-rappeler qu'il faut utiliser des bons noms de variables et qu'il
faut éviter d'utiliser localement un nom de variable globales
(ça peut conduire à des erreurs ou a des comportement étranges
que j'expliquerai plus tard dans les vidéos). 
-montrer est expliquer l'erreur UnboundLocalError
var = 0
def func():
    print var

def func2():
    print var
    var = 1

func()
func2()
>>> 
0

Traceback (most recent call last):
  File "C:/Users/alegout/Desktop/test.py", line 12, in <module>
    func2()
  File "C:/Users/alegout/Desktop/test.py", line 8, in func2
    print var
UnboundLocalError: local variable 'var' referenced before assignment

## Quizz Vidéo 6

## Exercices Vidéo 6

-nombreux exemple de scope avec fonctions englobantes. 

###################################################################

## Vidéo 7 (Portée des variables dans les fonctions et références partagées)

C012AL-W4-S7.txt

## Compléments Vidéo 7

*montrer que global crée une variable global si elle n'existe
pas encore. 
x = 1
def f():
    global y
	y = x + 1
print y # n'existe pas encore
f()
print y # existe dans le scope global. 

*revenir sur les bonnes pratiques de programmation avec global (en 
limitant son usage et en favorisant les retours explicite de fonction). 

## Quizz Vidéo 7

## Exercices Vidéo 7


###################################################################

## Vidéo 8 (Passage d'arguments et appel de fonctions)

CO12AL-W4-VIDEO008.txt

## Compléments Vidéo 8

*introduire sys.argv en remarquant que c'est une forme *Targs
et introduire le module argparse. 
*donner des exemples pratiques de forme * et ** (si tu en as)
*montrer un exemple de mélange des 4 déclarations d'arguments
def f(a, c = 3, *d, **e)
*montrer l'erreur qu'il peut se produire lorsque l'on combine
des formes positionnelles et des formes nommés lors de l'appel.
def func(a, b, c, d):
    print a, b, c, d
func(1, c = 3, *(2,), **{'d':4})
>>>
1 2 3 4
>>> func(1, b = 3, *(2,), **{'d':4})
Traceback (most recent call last):
  File "<pyshell#170>", line 1, in <module>
    func(1, b = 3, *(2,), **{'d':4})
TypeError: func() got multiple values for keyword argument 'b'

Expliquer que les arguments ne sont pas pris dans l'ordre 
de l'appel, mais les arguments positionnel sont utilisé en premier. 
les arguments ordonnés et *args, ne donnent pas le nom des arguments, donc ils ne peut être que positionnel. Par contre, les arguments nommés et **args fournissent le nom. Ils sont donc traités en dernier. 
C'est expliqué dans Dans Python Language Reference: 5.3.4. Calls
https://docs.python.org/2/reference/expressions.html#calls

*montrer le piège des arguments par défaut qui ne sont initialisé
qu'une fois à la création de l'objet fonction, donc problème avec 
les mutables
https://docs.python.org/2/tutorial/controlflow.html#default-argument-values
def f(a, L = []):
    L.append(a)
    print L
f(1)
f(2)
f(3)
>>>
[1]
[1, 2]
[1, 2, 3]

Solutions
def f(a, L = None):
    if L is None:
        L = []
    L.append(a)
    print L
f(1)
f(2)
f(3)
>>>
[1]
[2]
[3]




## Quizz Vidéo 8

## Exercices Vidéo 8

